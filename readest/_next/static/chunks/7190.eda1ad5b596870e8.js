"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7190],{27190:(e,r,t)=>{t.d(r,{WebAppService:()=>w});var n=t(72101),o=t(94074),s=t(29803),a=t(79893),i=t(74615),c=t(36604),l=t(64371);let u=(e,r)=>{switch(r){case"Books":return{baseDir:0,fp:"".concat(l.zg,"/").concat(e),base:r};case"None":return{baseDir:0,fp:e,base:r};default:return{baseDir:0,fp:"".concat(r,"/").concat(e),base:r}}};async function f(){return new Promise((e,r)=>{let t=indexedDB.open("AppFileSystem",1);t.onupgradeneeded=()=>{let e=t.result;e.objectStoreNames.contains("files")||e.createObjectStore("files",{keyPath:"path"})},t.onsuccess=()=>e(t.result),t.onerror=()=>r(t.error)})}let p={getURL:e=>(0,s.Gz)(e)?e:URL.createObjectURL(new Blob([e])),async getBlobURL(e,r){try{let t=await this.readFile(e,r,"binary");return URL.createObjectURL(new Blob([t]))}catch(r){return e}},async openFile(e,r,t){return(0,s.Gz)(e)?await new a.T(e,t).open():new File([await this.readFile(e,r,"binary")],t||e)},async copyFile(e,r,t){let{fp:n}=u(r,t),o=await f();return new Promise((r,t)=>{let s=o.transaction("files","readwrite").objectStore("files"),a=s.get(e);a.onsuccess=()=>{let o=a.result;o?(s.put({path:n,content:o.content}),r()):t(Error("File not found: ".concat(e)))},a.onerror=()=>t(a.error)})},async readFile(e,r,t){let{fp:n}=u(e,r),o=await f();return new Promise((e,r)=>{let s=o.transaction("files","readonly").objectStore("files").get(n);s.onsuccess=async()=>{if(s.result){let n=s.result.content;"text"===t?e(n):n instanceof Blob?e(await n.arrayBuffer()):n instanceof ArrayBuffer?e(n):"string"==typeof n?e(new TextEncoder().encode(n).buffer):r(Error("Unsupported content type in IndexedDB"))}else r(Error("File not found: ".concat(n)))},s.onerror=()=>r(s.error)})},async writeFile(e,r,t){let{fp:n}=u(e,r),o=await f();return new Promise((e,r)=>{let s=o.transaction("files","readwrite");s.objectStore("files").put({path:n,content:t}),s.oncomplete=()=>e(),s.onerror=()=>r(s.error)})},async removeFile(e,r){let{fp:t}=u(e,r),n=await f();return new Promise((e,r)=>{let o=n.transaction("files","readwrite");o.objectStore("files").delete(t),o.oncomplete=()=>e(),o.onerror=()=>r(o.error)})},async createDir(){},async removeDir(){},async readDir(e){let r=await f();return new Promise((t,n)=>{let o=r.transaction("files","readonly").objectStore("files").getAll();o.onsuccess=()=>{t(o.result.filter(r=>r.path.startsWith(e)).map(e=>({path:e.path,isDir:!1})))},o.onerror=()=>n(o.error)})},async exists(e,r){let{fp:t}=u(e,r),n=await f();return new Promise((e,r)=>{let o=n.transaction("files","readonly").objectStore("files").get(t);o.onsuccess=()=>e(!!o.result),o.onerror=()=>r(o.error)})},getPrefix:()=>null};class w extends c.E{resolvePath(e,r){return u(e,r)}async getInitBooksDir(){return l.zg}async getCacheDir(){return"Cache"}async selectDirectory(){throw Error("selectDirectory is not supported in browser")}async selectFiles(){throw Error("selectFiles is not supported in browser")}constructor(...e){super(...e),(0,n._)(this,"fs",p),(0,n._)(this,"isMobile",["android","ios"].includes((0,s.Ox)())),(0,n._)(this,"appPlatform","web"),(0,n._)(this,"hasSafeAreaInset",(0,i.xx)()),(0,n._)(this,"getCoverImageUrl",e=>this.fs.getURL("".concat(l.zg,"/").concat((0,o.df)(e)))),(0,n._)(this,"getCoverImageBlobUrl",async e=>this.fs.getBlobURL("".concat(l.zg,"/").concat((0,o.df)(e)),"None"))}}}}]);